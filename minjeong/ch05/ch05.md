## 5장 데이터베이스 조작이 편해지는 ORM

### 데이터베이스란?
- 데이터를 효율적으로 보관하고 꺼내 볼 수 있는 곳

#### DBMS
- db는 많은 사람이 공유할 수 있어야 하므로 동시 접근이 필요함
- 이런 요구사항을 만족하면서 효율적으로 db를 관리하기 위한 소프트웨어
- MySQL, 오라클, H2
- 관계형, 객체-관계형,도큐먼트형, 비관계형 등으로 분류

#### RDBMS
- 관계형 DBMS
- 테이블 형태로 이루어진 데이터 저장소

#### H2
- 스프링부트가 지원하는 인메모리 RDBMS
- 자바로 작성
- 애플리케이션 자체 내부에 데이터를 저장 -> 애플리케이션을 다시 실행하면 데이터 초기화
- 개발시 : H2, 서비스로 올릴 때 : MySQL 사용 -> 도도독도 이랬음

#### db 용어
![img.png](img.png)
#### 기본키
- 행을 구분할 수 있는 식별자
- 테이블에서 유일
- 중복값, 수정, NULLx
#### 쿼리
- db 조작 명령문

### ORM
- 객체와 db를 연결하는 프로그래밍 기법
- db의 값을 마치 객체처럼 사용할 수 있음
- ORM 핵심 : ORM 을 사용해 Object와 RDB 사이에 객체지향적으로 다루기 위한 기술
- JPA, Hibernate, EclipseLink
- 장점
  - SQL을 직접 작성하지 않고 사용하는 언어로 db에 접근할 수 있음
  - 객체지향적으로 코드를 작성할 수 있어 비지니스 로직에만 집중 가능
  - db 시스템에 대한 종속성이 줄어듬(김영한이 말했던 그거. 레고 조립하듯이 쉽게 바꿀 수 있다)
  - 매핑하는 정보가 명확하기 때문에 ERD에 대한 의존도를 낮출 수 있고 유지보수 할 때 유리
- 단점
  - 플젝의 복잡성이 커질수록 사용 난이도도 올라감
  - 복잡하고 무거운 쿼리는 ORM으로 해결이 불가능한 경우가 있음

### JPA와 하이버네이트
- JPA
  - 자바에서 표준으로 사용하는 ORM
  - 자바에서 RDB를 사용하는 방식을 정의한 인터페이스(인터페이스 이므로 실제 사용을 위해서는 ORM 프레임워크를 추가로 선택해야 함)
- 하이버네이트
  - 자바 언어를 위한 ORM 프레임워크
  - JPA를 구현한 구현체로, 내부적으로 JDBC API를 사용
  - 목표 : 자바 객체를 통해 db 종류에 상관없이 데이터베이스를 자유자재로 사용할 수 있게함

### 엔티티 매니저
- 엔티티
  - db의 테이블과 매핑되는 자바 객체
  - db에 영항을 미치는 쿼리를 실행
- 엔티티 매니저
  - 엔티티를 관리해 db와 어플리케이션 사이에서 객체를 C,U,D의 역할을 함
- 엔티티 매니저 팩토리
  - 엔티티 매니저를 만드는 곳
  - 스프링 부트는 내부에서 앤티티 매니저 팩토리를 하나만 생성해서 관리하고 @Persistence Context 또는 @Autowired를 사용해서 엔티티 매니저를 사용
  - 엔티티 매니저는 Spring Data JPA에서 관리하므로 개발자가 직접 생성하거나 관리할 필요가 없음 
  - -db에 접근할 때는 Repository를 정의하여 사용하므로 앤티티 매니저를 잘 사용하지 않음

### 영속성 컨텍스트
- 엔티티를 관리하는 가상의 공간
- 영속성 컨텍스트 때문에 db에서 효과적으로 데이터를 가져오고, 엔티티를 편하게 사용할 수 있음
-  엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
- 특징 (공통점 : db와의 접근을 최소화해 성능을 높일 수 있다는 것)
  - 1차 캐시 
    - 영속성 컨턱스트는 내부에 1차 캐시를 가지고 있음
    - 1차 캐시의 키는 @Id가 달린 기본키 역할을 하는 식별자이고 값은 엔티티
    - 조회의 흐름
      - 1.1차 캐시에서 엔티티를 찾는다
      - 2.있으면 메모리에 있는 1차 캐시에서 엔티티를 조회한다.
      - 3.없으면 데이터베이스에서 조회한다.
      - 4.조회한 데이터로 엔티티를 생성해 1차 캐시에 저장한다. (엔티티를 영속상태로 만든다)
      - 5.조회한 엔티티를 반환한다.
   - 쓰기 지연
     - 트랜잭션을 커밋하기 전까지는 db에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것
     - ex) 데이터 추가 쿼리가 3개라면 영속성 컨텍스트는 트랜잭션을 커밋하는 시점에서 3개의 쿼리를 한꺼번에 전송
   - 변경 감지
     - 트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 db에 자동으로 반영
     - JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터를 변경하면 됨
     - ! 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티만 적용

   - 지연 로딩
     - 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것

### 엔티티의 상태
- 비영속 상태 : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 관리 상태 : 영속성 컨텍스트에 저장된 상태
- 분리 상태 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제된 상태

### 스프링 데이터 JPA
- 스프링 데이터
  - 비지니스 로직에 더 집중할 수 있게 db 사용 기능을 클래스 레벨에서 추상화 함
  - 스플이 데이터에서 제공하는 인터페이스를 통해 스프링 데이터를 사용할 수 있음
  - CRUD를 포함한 여러 메서드가 포함되어 있음
  - 알아서 쿼리를 만들어줌
  - 페이징 처리 기능, 메서드 이름으로 쿼리 빌딩하는 기능이 제공됨
  - db의 특성에 맞춰 기능을 확장해 제공하는 기술도 제공. ex) JPA : 스프링에서 구현한 스프링 데이터 JPA, 몽고디비 : 스프링 데이터 몽고디비

- 스프링 데이터 JPA
  - JPA를 쓰기 편하게 만들어놓은 모듈
  - 스프링 데이터의 인터페이스인 PagingAndSortingRepository를 상속받아 JpaRepository 인터페이스를 만듦
```java
// 기존에 엔티티 상태를 바꾸는 방법(메서드 호출을 통해 상태 변경)
@PersistenceContest
EntityManager em;

public void join(){
    Member member = new Member(1L, "홍길동");
    em.persist(member);
        }
```
  - 스프링 데이터 JPA를 사용하면 레포지터리 역할을 하는 인터페이스를 만들어 CRUD를 간단히 할 수 있음 
```java
// 스프링 데이터 JPA 사용시
public interface MemberRepository extends JpaRepository<Member,Long>{
}
```
### 스프링 데이터 JPA에서 제공하는 메서드 사용하기

```java
import javax.annotation.processing.Generated;

@Entity //엔티티로 지정
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED) //기본 생성자
@AllArgsConstructor
public class Member {
  @Id //id 필드를 기본키로 지정
  @GeneratedValue(strategy = GenerationType.IDENTITY) //기본키 생성 방식
  @Column(name = "id", updatable = false)
  private Long id
          
  @Column(name = "name", nullable = false)
  private String name;
}
```
#### 기본키 생성 방식
- AUTO : 선택한 데이터베이스 방언에 따라 방식을 자동으로 선택
- IDENTITY : 기본 키 생성을 데이터베이스에 위임(AUTO_INCREMENT)
- SEQUENCE : db 시퀀스를 사용해서 기본키를 할당하는 방법
- TABLE : 키 생성 테이블 사용