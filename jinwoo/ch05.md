# ch05. 데이터베이스 조작이 편해지는 ORM

# 1. 데이터베이스

## 1-1. DBMS

DBMS란? 데이터베이스 매니지먼트 시스템. 데이터베이스를 관리하기 위한 소프트웨어이다.

데이터베이스는 많은 사람이 사용할 수 있어야 하므로 동시 접근이 가능해야 한다, 이 외에도 많은 요구사항을 만족하며 효율적으로 db를 관리하고 운영해야 한다.

Mysql, 오라클 등이 dbms이다

### RDBMS

관계형 데이터베이스. 관계형 모델을 기반으로 한다.

테이블 형태로 이루어진 데이터 저장소이다.

행(ROW)과 열(Column)로 이루어짐

### H2, mysql

h2는 자바로 작성된, 인메모리 rdbms이다. 어플리케이션 내부에 데이터를 저장하기 떄문에, 어플리케이션을 다시 실행하게 되면 초기화 된다.

H2는 개발 용도로 많이 사용되고,  실제 프로덕션에선 mysql을 사용한다.

### 필수 용어 정리

- 테이블 : 데이터를 구성하기 위한 기본 단위. 행과 열로 이루어짐
- 행(row, record) : 가로로 배열된 데이터의 집합. 행은 반드시 고유 식별자인 기본키를 가짐
- 열(colummn) : 행에 저장되는 데이터의 유형. 데이터 무결성 보장?
- 기본키 : 행을 구별하는 식별자. 테이블에서 유일해야하며 중복이 안되고, 널불가
- 쿼리 : 데이터베이스에서 데이터를 crud할 때 사용하는 명령

# 2. ORM이란?

ORM(Object Relational mapping) : 자바의 객체와 db를 연결하는 프로그래밍 기법

데이터베이스의 객체를 자바코드에서 사용하려고 하면, sql을 통해 꺼내어 사용해야 할 것이다.

하지만! ORM이 있다면 데이터베이스의 값을 객체처럼 사용할 수 있다. 자바 언어로만 db에 접근하여 원하는 데이터를 가져올 수있다는 것이다. 그리고 이러한 도구를 orm이라고 한다,.

### ORM의 장점

- sql을 직접 작성하지 않고 사용하는 언어로 db에 접근 가능하다
- 객체지향적으로 코드를 작성 가능하며, 비즈니스 로직에 집중 가능하다
- db시스템이 추상화되어있다. 즉 db 종속성이 줄어든다
- 매핑 정보가 명확하므로, erd의존도를 낮출 수 있고 유지보수에 용이하다

### ORM의 단점

- 프로젝트가 복잡해지면 난이도가 올라간다
- 복잡하고 무거운 쿼리는 orm으로도 해결이 불가능하다

# 3. JPA와 하이버네이트

ORM에도 여러가지 종류가 있다.

자바에서는 **JPA**를 표준으로 사용한다. JPA는 자바에서 rdmbs를 사용하는 방식을 정의한 **인터페이스**이다. 인터페이스이므로, 실제 사용을 위해서는 orm프레임워크를 선택해야 하는데, 대표적으로 **하이버네이트**를 많이 사용한다,

**하이버네이트**는 jpa인터페이스를 구현한 구현체이면서, 자바용 orm 프레임워크이다. 내부적으로 JDBC api를 사용한다.

## 3-1. 엔티티 매니저란?

### 엔티티

데이터베이스의 테이블과 매핑되는 객체이다. 본질적으로는 자바 객체이다. 하지만 데이터베이스의 테이블과 직접 연결된다는 특징이 있다.

### 엔티티 매니저

엔티티 매니저는, 엔티티를 관리해 데이터베이스와 어플리케이션 사이에서 객체를 CRUD하는 역할을 한다.그리고 이런 엔티티 매니저를 만드는 곳이 **엔티티 매니저 팩토리**이다.

회원 2명이 동시에 회원가입을 한다고 하자. 

이때 회원1의 요청에 대해 가입 처리를 할 엔티티매니저를 엔티티매니저팩토리가 만든다.

그리고 회원2의 요청에 대해 가입 처리를 할 엔티티매니저를 엔티티매니저팩토리가 만든다.

그리고 가각각의 엔티티 매니저는 **필요한 시점에 db와 연결**하여 쿼리한다.

**스프링부트에서는 직접 엔티티 매니저 팩토리를 만들어 관리하지 않는다**.

스프링부트 내붸서는 엔티티 매니저 팩토리를 하나만 생성하여 관리하고, `@PersistenceContext` 또는 `@Autowired` 어노테이션을 사용해서 엔티티매니저를 사용한다.

```java
@PersistenceContext
EntityManager em; //프록시엔티티매니저
```

스프링부트는 기본적으로 빈을 하나만 생성해서 공유한다, 고로 동시성 문제가 발생할 수 있다.(왜??)

그래서 실제로는, 실제 엔티티매니저와 연결하는 프록시 엔티티 매니저를 사용한다. 필요할 때 db트랜잭션과 관련된 실제 엔티티 매니저를 호출하는 것이다.

→ 즉 Spring Data JPA에서 관리하기 때문에 우리가 관리하거나 생성할 필요가 없다!

## 3-2. 영속성 컨텍스트란?

엔티티 매니저는, 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있다.

**영속성 컨텍스트는,** Jpa의 특징 중 하나로 엔티티를 관리하는 가상의 공간이다.

이것이 있기 때문에 데이터베이스에서 효과적으로 데이터를 가져올 수 있고 엔티티를 편하게 사용할 수 있

영속성 컨텍스트의 네 가지 특징에 대해 알아보자

기존에는 데이터 조작을 위해 쿼리를 직접 작성해야 했지만, 스프링부트에서는 이런 쿼리를 자바 코드로 작성하고, 이를 JPA가 알아서 쿼리로 변경해주는 것이 매우 편리하다. 그치만 **영속성 컨텍스트를 꼭 알자**

### 1차 캐시

영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다. 캐시의 키는 `@Id` 어노테이션이 달린 **기본키**이며, **값은 엔티티**이다.

엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 있으면 반환한다.

값이 없으면 db에서 조회하고 1차 캐시에 저장한다.

따라서 캐시된 데이터를 조회하면 매우 빠르게 조회 가능하다

### 쓰기 지연

**쓰기 지연이란,** 트랜잭션을 커밋하기 전까지 데이터베이스에 실제 질의문을 보내지 않고, 쿼리를 모아두었다가- **트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미한다.**

데이터 추가 쿼리가 3개일 떄, 트랜잭션을 커밋하는 시점에 3개의 쿼리를 한번에 전송한다. dbms의 부담을 줄인다.( 커밋 시점이 언제..)

### 변경 감지

트랜잭션을 커밋하**면, 1차 캐시에 저장되어있는 엔티티 값과 현재 엔티티 값을 비교한다.** 변경된 값이 있다면 변경 사항을 감지하여 변경된 값을 자동으로 db에 반영한다.

쓰기지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할 수 있고, dbms의 부담을 줄인

### 지연 로딩

**지연 로딩은,** 쿼리로 요청한 데이터를 어플리케이션에 바로 로딩하는 것이 아니라, 필요할 때 쿼리를 날려 조회하는 것을 말한다.

(반대로 조회할 떄 바로 쏘는 즉시로딩도 있음)

이 특징의 공통점은, db의 접근을 최소화하여 성능을 높이는 것이다.

캐시 or 자주 쓰지 않게 하거나, 변화를 감지하여 미리 준비.

## 3-3. 엔티티의 상태

- 분리(detached) 상태 : 영속성 컨텍스트가 관리하고 있지 않음
- 관리(managed) 상태 : 영속성 컨텍스트가 관리 중
- 비영속(translent) 상태 : 영속성 컨텍스트와 전혀 관계가 없음
- 삭제된(deleted) 상태 :

이 상태들은, 특정 메서드를 호출하여 변경할 수 있다,

```java
@Autowired
EntityManager em;

public void example(){
	
	Member member = new Member(1L, "홍길동"); // 비영속
	
	em.persist(member); // 관리 
	em.detach(member); // 분리
	em.remove(member); // 삭
}
```

# 4. 스프링데이터와 스프링데이터 JPA

지금까지는 엔티티 상태를 직접 관리해야 했다.

**스프링데이터**는 비즈니스로직에 집중할 수 있도록 db사용기능을 클래스레벨에서 추상화 했다, 따라서 스프링데이터에서 제공하는 인터페이스를 이용하여 스프링데이터를 사용할 수 있다.

이 인터페이스는 CRUD를 포함한 여러 메서드가 있으며, **알아서** 쿼리를 만들어준다. 이외에 페이징처리 기능, 메서드이름으로 쿼리를 빌딩하는 기능 등이 있다.

표준 스펙인 JPA는 스프링에서 구현한 스프링데이터JPA를 사용한다!!!

## 4-1. 스프링데이터 JPA

**스프링데이터JPA는** 스프링 데이터의 공통적인 기능에서 JPA의 유용한 기술이 추가된 기술이다. 

스프링뎅터jpa를 사용하면, 레포지토리 역할을 하는 인터페이스를 만들어 db의 테이블조회, ㅜ정, 생성, 삭제 등이 가능하다.

```java
public interface MemberRepository extends JpaRepository<Member,Long>{
}
```

제네릭은 <**엔티티 이름, 엔티티 기본키 타입**>이다.

## 4-2. 스프링데이터JPA에서 제공하는 메서드 사용해보기

```java
@Service
public class MemberService {
    @Autowired
    MemberRepository memberRepository;

    public void test() {
    // 생성
        memberRepository.save(new Member(1L, "A"));

        Optional<Member> member = memberRepository.findById(1L); //단건 조회
        List<Member> =memberRepository.findAll(); //전체 조회
        
        memberRepository.deleteById(1L); //삭
    }
}
```

```java
@Entity
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Model {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "MODEL_ID", nullable = false)
    private Long id;

    @Column(name = "IMAGE_URL", nullable = false)
    private String imageUrl;

    @Column(name = "MODEL_NAME", nullable = false)
    private String modelName;
   }
```

- `@Entity` 어노테이션
    
    Member객체를 JPA가관리하는 엔티티로 지정. 즉 Member클래스와 실제 데이터베이스의 테이블을 매핑함.
    
    `name`속성을 사용하면 해당 name 값을 각진 테이블 이름과 매핑됨
    
- `protected` 기본 생성자
    
    엔티티는 반드시 기본 생성자가 있어야 하고, 접근 제어가는 public 또는 protected이어야 한다, 좀 더 안전한 프로테테그트티드
    
- `@GeneragedValue`
    
    기본키의 생성 방식을 결정한다.
    
    - Auto : 선택한 db 방언에 따라 결정
    - IDENTITY : 기본키 생성을 db에 위임(AUTO_INCREMENT)
    즉 자동으로 1씩 증가
    - SEQUENCE : db시퀀스를 사용해서 기본키를 할당. 주로 오라클에서 사용
    - TABLE : 키 생성 테이블 사용
- `@Column`
    
    데이터베이스의 컬럼과 필드를 매핑
    
    - name, nullable, unique, cloumnDefinition 등 속성 가